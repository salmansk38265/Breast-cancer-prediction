# -*- coding: utf-8 -*-
"""Breast Cancer Code

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ntgzgerp-jp3dJ2ZvJP26uwdncdmCdBk

# Breast Cancer Prediction Using Machine Learning.

<div class="text-success "><h3> Table Of Contains</h3></div>

---

> ### Steps are:


1. [Gathering Data](#1)
2. [Exploratory Data Analysis](#2)
3. [Data Visualizations](#3)
4. [Model Implementation.](#4)
5. [ML Model Selecting and Model PredPrediction](#5)
6. [HyperTunning the ML Model](#6)
7. [Deploy Model](#7)

<center><img src="https://healthitanalytics.com/images/site/article_headers/_normal/ThinkstockPhotos-495951912.jpg" alt="Breast Cancer Prediction Using Machine Learning" height="70%" width="100%" /></center>

### Attribute Information:

1. ID number
- Diagnosis (M = malignant, B = benign)

Ten real-valued features are computed for each cell nucleus:

1.  radius (mean of distances from center to points on the perimeter)
2.  texture (standard deviation of gray-scale values)
3.  perimeter
4.  area
5.  smoothness (local variation in radius lengths)
6.  compactness (perimeter^2 / area - 1.0)
7.  concavity (severity of concave portions of the contour)
8.  concave points (number of concave portions of the contour)
9.  symmetry
10. fractal dimension ("coastline approximation" - 1)
"""

import numpy as np
import pandas as pd

pd.options.display.max_columns = 100

"""After installing numpy and pandas package, we are ready to fetch data using pandas package, Befor we use it, We need to know where's our dataset located. Means what is the path of our dataset

<a id="1"></a><br>

# 1. Data Collection.
"""

from google.colab import files # type: ignore
uploaded = files.upload()

data = pd.read_csv(BreastCancer.csv")

"""After collecting data, we need to know what are the shape of this dataset, Here we have attribute(`property`) called `data.shape`

For that we have 2 type of methods to show the shape of the datasets.

1. `len(data.index), len(data.columns)`
- `data.shape`

Both methods are giving us the same output, As you can see in the below cells`
"""

# Cell 1
len(data.index), len(data.columns)

# Cell 2
data.shape

data.head()

data.tail()

"""<a id="2"></a><br>
# 2. Exploring Data Analysis
"""

data.info()

data.isna()

data.isna().any()

data.isna().sum()

data = data.dropna(axis='columns')

"""### Get object features

- Using this method, we can see how many `object(categorical)` type of feature exists in dataset
"""

data.describe(include="O")

"""- *As we can see abouve result there are only one single feature is categorical and it's values are `B` and `M`*

### To know how many unique values
"""

data.diagnosis.value_counts()

"""using  `value_counts` method we can see number of unique values in categorical type of feature.

### Identify dependent and independent
"""

data.head(2)

diagnosis_unique = data.diagnosis.unique()

diagnosis_unique

"""<a id="3"></a><br>

# 3. Data Visualization.
"""

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
import plotly.graph_objects as go

# %matplotlib inline
sns.set_style('darkgrid')

plt.figure(figsize=(15, 5))

plt.subplot(1, 2, 1)
plt.hist( data.diagnosis)
# plt.legend()
plt.title("Counts of Diagnosis")
plt.xlabel("Diagnosis")


plt.subplot(1, 2, 2)

sns.countplot(data=data);

# plt.show()

cols = ["diagnosis", "radius_mean", "texture_mean", "perimeter_mean", "area_mean"]

sns.pairplot(data[cols], hue="diagnosis")
plt.show()

# plt.figure(figsize=(7,12))
px.histogram(data, x='diagnosis')
# plt.show()

size = len(data['texture_mean'])

area = np.pi * (15 * np.random.rand( size ))**2
colors = np.random.rand( size )

plt.xlabel("texture mean")
plt.ylabel("radius mean")
plt.scatter(data['texture_mean'], data['radius_mean'], s=area, c=colors, alpha=0.5);

"""### Data Filtering

- Now, we have one categorical feature, so we need to convert it into numeric values using `LabelEncoder` from `sklearn.preprocessing` packages
"""

from sklearn.preprocessing import LabelEncoder

data.head(2)

"""* LabelEncoder can be used to normalize labels.

"""

labelencoder_Y = LabelEncoder()
data.diagnosis = labelencoder_Y.fit_transform(data.diagnosis)

"""After converting into numerical values, we can check it's values using this way,"""

data.head(2)

print(data.diagnosis.value_counts())
print("\n", data.diagnosis.value_counts().sum())

"""Finnaly, We can see in this output categorical values converted into 0 and 1.

#### Find the correlation between other features, mean features only
"""

cols = ['diagnosis', 'radius_mean', 'texture_mean', 'perimeter_mean',
       'area_mean', 'smoothness_mean', 'compactness_mean', 'concavity_mean',
       'concave points_mean', 'symmetry_mean', 'fractal_dimension_mean']
print(len(cols))
data[cols].corr()

plt.figure(figsize=(12, 9))

plt.title("Correlation Graph")

cmap = sns.diverging_palette( 1000, 120, as_cmap=True)
sns.heatmap(data[cols].corr(), annot=True, fmt='.1%',  linewidths=.05, cmap=cmap);

"""Using, Plotly Pacage we can show it in interactive graphs like this,"""

plt.figure(figsize=(15, 10))


fig = px.imshow(data[cols].corr());
fig.show()

"""<a id="4"></a><br>

# Model Implementation

---
---


#### Train Test Splitting

##### Preprocessing and model selection
"""

from sklearn.model_selection import train_test_split

from sklearn.preprocessing import StandardScaler

"""### Import Machine Learning Models

"""

from sklearn.linear_model import LogisticRegression

from sklearn.tree import DecisionTreeClassifier

from sklearn.ensemble import RandomForestClassifier

from sklearn.naive_bayes import GaussianNB

from sklearn.neighbors import KNeighborsClassifier

"""### Check the Model Accuracy, Errors and it's Validations"""

from sklearn.metrics import accuracy_score, confusion_matrix, f1_score

from sklearn.metrics import classification_report

from sklearn.model_selection import KFold

from sklearn.model_selection import cross_validate, cross_val_score

from sklearn.svm import SVC

from sklearn import metrics

"""### Feature Selection

Select feature for predictions
"""

data.columns

"""- Take the dependent and independent feature for prediction"""

prediction_feature = [ "radius_mean",  'perimeter_mean', 'area_mean', 'symmetry_mean', 'compactness_mean', 'concave points_mean']

targeted_feature = 'diagnosis'

len(prediction_feature)

X = data[prediction_feature]
X

# print(X.shape)
# print(X.values)

y = data.diagnosis
y

# print(y.values)

"""- Splite the dataset into TrainingSet and TestingSet by 33% and set the 15 fixed records"""

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33, random_state=15)

print(X_train)
# print(X_test)

"""### Perform Feature Standerd Scalling

Standardize features by removing the mean and scaling to unit variance

The standard score of a sample x is calculated as:

- z = (x - u) / s
"""

# Scale the data to keep all the values in the same magnitude of 0 -1

sc = StandardScaler()

X_train = sc.fit_transform(X_train)
X_test = sc.fit_transform(X_test)

"""<a id="5"></a><br>
# ML Model Selecting and Model PredPrediction



---
---

#### Model Building

Now, we are ready to build our model for prediction, for the I made function for model building and preforming prediction and measure it's prediction and accuracy score.

####  Arguments
1. model => ML Model Object
2. Feature Training Set data
3. Feature Testing Set data
4. Targetd Training Set data
5. Targetd Testing Set data
"""

def model_building(model, X_train, X_test, y_train, y_test):
    """

    Model Fitting, Prediction And Other stuff
    return ('score', 'accuracy_score', 'predictions' )
    """

    model.fit(X_train, y_train)
    score = model.score(X_train, y_train)
    predictions = model.predict(X_test)
    accuracy = accuracy_score(predictions, y_test)

    return (score, accuracy, predictions)

"""Let's make a dictionary for multiple models for bulk predictions"""

models_list = {
    "LogisticRegression" :  LogisticRegression(),
    "RandomForestClassifier" :  RandomForestClassifier(n_estimators=10, criterion='entropy', random_state=5),
    "DecisionTreeClassifier" :  DecisionTreeClassifier(criterion='entropy', random_state=0),
    "SVC" :  SVC(),
}

# print(models_list)

"""Before, sending it to the prediction check the key and values to store it's values in DataFrame below."""

print(list(models_list.keys()))
print(list(models_list.values()))

# print(zip(list(models_list.keys()), list(models_list.values())))

"""### Model Implementing

Now, Train the model one by one and show the classification report of perticular models wise.
"""

# Let's Define the function for confision metric Graphs

def cm_metrix_graph(cm):

    sns.heatmap(cm,annot=True,fmt="d")
    plt.show()

df_prediction = []
confusion_matrixs = []
df_prediction_cols = [ 'model_name', 'score', 'accuracy_score' , "accuracy_percentage"]

for name, model in zip(list(models_list.keys()), list(models_list.values())):

    (score, accuracy, predictions) = model_building(model, X_train, X_test, y_train, y_test )

    print("\n\nClassification Report of '"+ str(name), "'\n")

    print(classification_report(y_test, predictions))

    df_prediction.append([name, score, accuracy, "{0:.2%}".format(accuracy)])

    # For Showing Metrics
    confusion_matrixs.append(confusion_matrix(y_test, predictions))


df_pred = pd.DataFrame(df_prediction, columns=df_prediction_cols)

print(len(confusion_matrixs))

plt.figure(figsize=(10, 2))
# plt.title("Confusion Metric Graph")


for index, cm in enumerate(confusion_matrixs):

#     plt.xlabel("Negative Positive")
#     plt.ylabel("True Positive")



    # Show The Metrics Graph
    cm_metrix_graph(cm) # Call the Confusion Metrics Graph
    plt.tight_layout(pad=True)

"""While Predicting we can store model's score and prediction values to new generated dataframe"""

df_pred

"""- print the hightest accuracy score using sort values"""

df_pred.sort_values('score', ascending=False)
# df_pred.sort_values('accuracy_score', ascending=False)

"""<a id="6"></a><br>
# HyperTunning the ML Model


---
---



### Tuning Parameters applying...

<!-- https://www.kaggle.com/gargmanish/basic-machine-learning-with-cancer  -->
"""

import warnings
warnings.filterwarnings('ignore')

from  sklearn.model_selection import GridSearchCV

"""For HyperTunning we can use `GridSearchCV` to know the best performing parameters

- GridSearchCV implements a “fit” and a “score” method. It also implements “predict”, “predict_proba”, “decision_function”, “transform” and “inverse_transform” if they are implemented in the estimator used.

- The parameters of the estimator used to apply these methods are optimized by cross-validated grid-search over a parameter grid.
"""

# Let's Implement Grid Search Algorithm

# Pick the model
model = DecisionTreeClassifier()

# Tunning Params
param_grid = {'max_features': ['auto', 'sqrt', 'log2'],
              'min_samples_split': [2,3,4,5,6,7,8,9,10],
              'min_samples_leaf':[2,3,4,5,6,7,8,9,10] }


# Implement GridSearchCV
gsc = GridSearchCV(model, param_grid, cv=10) # For 10 Cross-Validation

gsc.fit(X_train, y_train) # Model Fitting

print("\n Best Score is ")
print(gsc.best_score_)

print("\n Best Estinator is ")
print(gsc.best_estimator_)

print("\n Best Parametes are")
print(gsc.best_params_)

from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import GridSearchCV

# Assuming you have X_train, y_train defined somewhere

# Create a Random Forest classifier
model = RandomForestClassifier()

# Simplified Tuning Params
param_grid = {
    'n_estimators': [50, 100],
    'max_depth': [None, 10],
    'min_samples_split': [2, 5],
    'min_samples_leaf': [1, 2],
    'bootstrap': [True, False]
}

# Implement GridSearchCV
gsc = GridSearchCV(model, param_grid, cv=5)

# Model Fitting
gsc.fit(X_train, y_train)

print("\n Best Score is ")
print(gsc.best_score_)

print("\n Best Estimator is ")
print(gsc.best_estimator_)

print("\n Best Parameters are")
print(gsc.best_params_)

# Pick the model
model = SVC()


# Tunning Params
param_grid = [
              {'C': [1, 10, 100, 1000],
               'kernel': ['linear']
              },
              {'C': [1, 10, 100, 1000],
               'gamma': [0.001, 0.0001],
               'kernel': ['rbf']
              }
]


# Implement GridSearchCV
gsc = GridSearchCV(model, param_grid, cv=10) # 10 Cross Validation

# Model Fitting
gsc.fit(X_train, y_train)

print("\n Best Score is ")
print(gsc.best_score_)

print("\n Best Estinator is ")
print(gsc.best_estimator_)

print("\n Best Parametes are")
print(gsc.best_params_)

from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import GridSearchCV

# Assuming you have X_train, y_train defined somewhere

# Create a Logistic Regression classifier
model = LogisticRegression()

# Tuning Params
param_grid = {
    'penalty': ['l1', 'l2', 'elasticnet', 'none'],
    'C': [0.001, 0.01, 0.1, 1, 10, 100],
    'solver': ['newton-cg', 'lbfgs', 'liblinear', 'sag', 'saga'],
    'max_iter': [100, 200, 300]
}

# Implement GridSearchCV
gsc = GridSearchCV(model, param_grid, cv=10)

# Model Fitting
gsc.fit(X_train, y_train)

print("\n Best Score is ")
print(gsc.best_score_)

print("\n Best Estimator is ")
print(gsc.best_estimator_)

print("\n Best Parameters are")
print(gsc.best_params_)

"""<a id="7"></a><br>
# 7. Ensemble models

## 7.1 Decision Tree + Random Forest
"""

from sklearn.ensemble import VotingClassifier

dt=DecisionTreeClassifier(max_features='sqrt', min_samples_leaf=3);
rf=RandomForestClassifier(min_samples_leaf=2, min_samples_split=5);

ensemble_model = VotingClassifier(estimators=[('decision_tree', dt), ('random_forest', rf)], voting='hard')

ensemble_model.fit(X_train, y_train)

# Make predictions on the testing data
predictions = ensemble_model.predict(X_test)

# Calculate accuracy
accuracy = accuracy_score(y_test, predictions)
print(f"Accuracy: {accuracy}")

"""## 7.2 SVC + Logistic Regression

"""

from sklearn.ensemble import VotingClassifier

svc=SVC(C=10, gamma=0.001);
lr=LogisticRegression(C=0.001, solver='liblinear');

ensemble_model = VotingClassifier(estimators=[('svc', svc), ('logistic_regression', lr)], voting='hard')

ensemble_model.fit(X_train, y_train)

# Make predictions on the testing data
predictions = ensemble_model.predict(X_test)

# Calculate accuracy
accuracy = accuracy_score(y_test, predictions)
print(f"Accuracy: {accuracy}")

"""<a id="7"></a><br>
# 8. Deploy Model

- Finally, we are done so far. The last step is to deploy our model in production map. So we need to export our model and bind with web application API.

Using pickle we can export our model and store in to `model.pkl` file, so we can ealy access this file and calculate customize prediction using Web App API.


### A little bit information about pickle:

`Pickle` is the standard way of serializing objects in Python. You can use the pickle operation to serialize your machine learning algorithms and save the serialized format to a file. Later you can load this file to deserialize your model and use it to make new predictions


>>  Here is example of the Pickle export model



```
model.fit(X_train, Y_train)
# save the model to disk
filename = 'finalized_model.sav'
pickle.dump(model, open(filename, 'wb'))

# some time later...

# load the model from disk
loaded_model = pickle.load(open(filename, 'rb'))
result = loaded_model.score(X_test, Y_test)
print(result)
```
"""

import pickle as pkl

filename = 'ensembleModel.pkl'
pkl.dump(ensemble_model, open(filename, 'wb')) # wb means write as binary

"""#### Now, You can check your current directory. You can see the file with named "ensembleModel.pkl"

- To read model from file

```
# load the model from disk
loaded_model = pkl.load(open(filename, 'rb')) # rb means read as binary
result = loaded_model.score(X_test, Y_test)

```
"""
